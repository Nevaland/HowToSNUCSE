# Branch
브랜치는, 이름 그대로 나뭇가지와 같은 역할을 합니다.

## 이해하기
`git init`을 하고 나서, `master` 브랜치에 계속 커밋을 쌓아왔다고 합시다.
```
0000011 <- master
|
0000010
|
…
```
이 시점에서, `master`로부터 `branch1` 브랜치를 새로 만들어보면, 구조가 다음과 같이 나타납니다.
```
0000011 <- master, branch1
|
0000010
|
…
```
아직 `branch1`에 커밋을 하나도 쌓지 않았으므로, `master`브랜치와 차이가 없습니다.
이제, `branch1`에 커밋을 쌓아봅시다.
```
0000012 <- branch1
|
0000011 <- master
|
0000010
|
…
```
새로 쌓은 커밋 `0000012`를, `branch1`은 가리키고 있지만, `master`는 가리키고 있지 않는 모습을 볼 수 있습니다.
이번엔 `master`에 쌓아 보면,
```
0000012 <- branch1    0000013 <- master
|                    /
0000011 ────────────
|
0000010
|
…
```
새로 쌓은 커밋 `0000013`을, `master`는 가리키고 있지만, `branch1`은 가리키고 있지 않습니다.
이 둘은 커밋 `0000011` 로부터 분기되어, 각각 다른 커밋 히스토리를 가집니다.
이 모양이 마치 나뭇가지와 같아서 **branch**라는 이름이 붙여집니다.

### Merge
이제 `branch1`에 있는 내용과 `master`에 있는 내용을 합쳐봅시다.
머지에는 방향이 존재합니다. `branch1`에서 `master`로 머지할 수도 있고, `master`에서 `branch1`으로 머지할 수도 있습니다.
일반적으로, 파생 브랜치(이 경우 `branch1`)에서 주 브랜치(대부분의 경우 `master`)로 머지가 진행됩니다.
`branch1`에서 `master`로 머지해봅시다.
```
0000014 <- master
|      \_____________
0000013               0000012 <- branch1
|                    /
0000011 ────────────
|
…
```
`master`브랜치에 새로운 커밋 `0000014`가 쌓였습니다.
이 커밋을 **머지 커밋** 이라고 부릅니다. 
`branch1`은 그대로 있습니다. 이제 이 브랜치는 계속 커밋을 쌓을 수도 있고, 삭제해버릴 수도 있습니다.

머지 커밋이 발생하지 않는 경우도 있습니다.
주 브랜치에 아무런 커밋이 없는 경우가 그렇습니다.
다음 상황을 가정해봅시다.
```
0000012 <- branch1
|
0000011 <- master
|
0000010
|
…
```
이 상황에서 `branch1`로부터 `master`로 머지를 진행하면, *합칠* 내용이 존재하지 않기 때문에, fast-forward 머지가 진행됩니다.
fast-forward 머지가 발생한 이후의 상황은 다음과 같습니다.
```
0000012 <- master, branch1
|
0000011
|
0000010
|
…
```
단순히 `master` 브랜치가 가리키는 커밋을 `branch1`이 가리키는 커밋과 동일하게 만들어줍니다.
이 과정에서 새로운 커밋은 발생하지 않습니다.